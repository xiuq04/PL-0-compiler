# 编译原理实验报告
## 团队分工
每个人都完成了一份完整的代码
## 个人完成度：
由于这次实验内容不太好分工，所以我们组内成员决定每人各写一份完整的代码。所以这次的完成度是整个实验

## 整体思路：

- 先通过ｆｇｅｔｃ将字符一个一个的读进来，然后根据输入情况的不同，将之分为ｓｙｍｂｏｌ，ｌｅｔｔｅｒ（保留字和ｉｄｅｎｔｉｆｉｅｒ到后面再处理），ｎｕｍｂｅｒ，ｃｏｍｍｅｎｔｓ，以及其他（ＴＯＫＥＮ_ＮＵＬＬ）.
- 对每一个状态分别进行细分，最后确定具体为哪一类ＴＯＫＥＮ。同时，这在代码结构上的表现为两块：第一块是用来确定每一次TOKEN的输入之后所对应的状态是什么，第二块是用来处理对应的状态所确定的TOKEN是什么

## 个人实验过程中遇到的问题：
* 一开始还是想用fscanf来读入每个TOKEN然后进行分析的，但后面和组内成员讨论的时候发现这样有几个问题：1）无法区分换行符的输入和空格符的而输入，从而无法对token进行输入定位；2）与此同时，也难以处理没有用空格符之类的符号分开的不同类型的token。所以采取一个字符一个字符（fgetc）的读进来，然后进行分析。
* 在刚开始的时候觉得一个字符一个字符的进来问题有点多，需要处理的情况有点乱。在和同学讨论的时候发现用状态机（DFA）是一个很不错的选择，（这里感谢朱猛猛同学的提议）就相对简化了思路。
* 在处理多个字符连接在一起的时候按照一开始的要求就是长度不能超过１０，然后在后来的调试中就总是会出现连续的多个字符一起出现时，以空格或者换行等字符结尾的时候　就总是会正确读取一个字符然后吧结尾的空格或者换行之类的字符读进去取代了后面一个字符。经过很久很久很久很久的思考之后，发现时因为我虽然是一个字符一个字符读取进来的，但是如果是同类字符并且没有分割符的情况下就会，一次性将它全部读取进来。这样就导致后面分析的时候需要回退，但同时又因为最开始整体的结构的回退方式不适用一这种修改过后的，就会致使美都区一个字符就会丢失后面一个，并且使得行列进行相应的变化。最后的处理方法是利用合法字符的长度不超过二，然后限定字符ＴＯＫＥＮ的输入。再在结果出进行判断一下就好了（这样好像有点投机取巧，但是如果不这样的话就要大面积修改代码，所以ｅｍｍｍｍｍｍｍｍｍｍｍ）
* 还有就是在遇到//注释符号的时候，或报ＴＯＫＥＮ_NULL的错，和多行注释的时候行数计算会出错（后来怎么解决的就忘记了）
* 在最开始的时候对超长字符的的处理是直接将其置为TOKEN_NULL，所以会直接停止。后面改为了为其增加了一个类型IDTooLONG.
* 其实还有一些想不起来了。。。。。。
