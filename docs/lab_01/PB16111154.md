# lab_1 实验报告
###### PB16111154            朱猛猛

## 实验内容
本次实验的内容是编写PL0的词法分析器，由于本次实验内容不多，不好分工，所以我们组的每个组员都独自完成了本次实验（中间有讨论）。而我在本次实验的内容主要可以分成4个部分。

### 步骤一
在不考虑出错的情况下，对文件的内容进行词法分析。这一步骤是在pl0_lex.c的PL0Lex_get_token函数中进行的。我是利用了有限状态机来处理该问题的。首先是初始状态0，在这个状态下对从文件中读入的词的首字母进行讨论，一般对于长度为一的符号在这里就完成分析；状态1是处理identifier和reserved word的；状态2是讨论数字的；状态3是讨论除号'/'和注释的；状态4，5，6都是对注释的处理；状态8，8，9，10是对具有相同开头的符号或是多个字符组成的符号进行处理。

### 步骤二
得到每个词的所在行数以及其开始与结束位置。在pl0_lex.c定义全局变量row（行数）和position（位置），初始都为0。在pl0_lex.h中的结构体lex中增加成员变量row，bposition，eposition。在状态0时，将row赋值给lex->row，将position赋值给lex->bposition。而在得到确定的词时，将position赋值给lex->eposition。

### 步骤三
考虑文件中的词性出现错误。首先在，初始状态0中对于读取的字符不是所给词法里出现的字符进行报错。然后在PL0Lex_get_token函数中定义变量check，用来检验identifier长度是否超出范围，以及数字后是否跟了字母。check在初始状态0置为0，如果出现错误，就置为1，并在状态1和状态2中对check进行判断以显示错误。最后就是数字超出范围的问题了，这里用了一个变量i来记录数字长度以便在状态2中进行判断并显示错误。

### 步骤四
对test.c中的输出进行规范化。我们要在test.c里输出所分析的词以及它的位置，这里我使用了'\t'以及利用%-10s等来对齐输出。


## 遇到的问题
### 问题一
#### 1. 问题描述：
不熟悉linux系统，导致不知道修改过代码后如何在build里生成可执行文件test。
#### 2. 解决方案概述：
在build里之间make即可。
#### 3. 具体细节：
在我大致完成了步骤一后，我先执行一下我的代码试一下，结果发现在build里cmake .. 并没有用。我以为是之间的代码写错了，在多次检查没发现问题后，怀疑不是用这条指令来生成可执行文件的。然后我想到了上学期的os实验好像是用make clean以及make来完成的，于是试了一下，发现果然是这样。
#### 4. 总结问题和经验教训：
对Ubuntu系统不够熟悉。

### 问题二
#### 1. 问题描述：
在完成报错时，发现总是在第一行结束的时候就会出现lex->last_token_type为 TOKEN_NULL的问题。
#### 2. 解决方案概述：
在初始状态0加上对空白符'\r'的识别。
#### 3. 具体细节：
在测试步骤二的时候总是在第一行读完就会出现越界的错误，发现是出现lex->last_token_type为 TOKEN_NULL的情况。然后我觉得应该是换行的问题，于是就上网查了一下换行符，结果发现一般windows里换行是'\r'、'\n'这两个字符一起使用的，于是就在初始状态0加上对空白符'\r'的识别。
#### 4. 总结问题和经验教训：
对字符的了解不深。



注：因为我在一天就把这次实验做的差不多了，所以做的时候没有多次commit。我只在做完后commit了一次。之后，又因为一些细节改了一部分，就又commot了一次。

